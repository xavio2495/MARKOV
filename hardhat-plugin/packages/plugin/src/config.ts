import { HardhatUserConfig } from "hardhat/config";
import { HardhatConfig } from "hardhat/types/config";
import { HardhatUserConfigValidationError } from "hardhat/types/hooks";

/**
 * This function validates the parts of the HardhatUserConfig that are relevant
 * to the plugin.
 *
 * This function is called from the `validateUserConfig` Hook Handler.
 *
 * @param userConfig The HardhatUserConfig, as exported in the config file.
 * @returns An array of validation errors, or an empty array if valid.
 */
export async function validatePluginConfig(
  userConfig: HardhatUserConfig,
): Promise<HardhatUserConfigValidationError[]> {
  const errors: HardhatUserConfigValidationError[] = [];

  // Validate legacy myConfig
  if (userConfig.myConfig !== undefined) {
    if (typeof userConfig.myConfig !== "object") {
      errors.push({
        path: ["myConfig"],
        message: "Expected an object with an optional greeting.",
      });
    } else {
      const greeting = userConfig.myConfig?.greeting;
      if (greeting !== undefined) {
        if (typeof greeting !== "string" || greeting.length === 0) {
          errors.push({
            path: ["myConfig", "greeting"],
            message: "Expected a non-empty string.",
          });
        }
      }
    }
  }

  // Validate markov config
  if (userConfig.markov !== undefined) {
    if (typeof userConfig.markov !== "object") {
      errors.push({
        path: ["markov"],
        message: "Expected an object with markov configuration.",
      });
      return errors;
    }

    const markov = userConfig.markov;

    // Validate optional string fields
    const stringFields = [
      "chain",
      "wallet",
      "author",
      "aiApiKey",
      "aiModel",
      "governanceAddress",
      "mcpEndpoint",
      "agentverseApiToken",
      "historyPath",
    ];

    for (const field of stringFields) {
      const value = markov[field as keyof typeof markov];
      if (value !== undefined && typeof value !== "string") {
        errors.push({
          path: ["markov", field],
          message: `Expected a string.`,
        });
      }
    }

    // Validate gasPrice (can be string or number)
    if (
      markov.gasPrice !== undefined &&
      typeof markov.gasPrice !== "string" &&
      typeof markov.gasPrice !== "number"
    ) {
      errors.push({
        path: ["markov", "gasPrice"],
        message: "Expected a string or number.",
      });
    }

    // Validate boolean fields
    if (markov.verbose !== undefined && typeof markov.verbose !== "boolean") {
      errors.push({
        path: ["markov", "verbose"],
        message: "Expected a boolean.",
      });
    }

    if (
      markov.autoSync !== undefined &&
      typeof markov.autoSync !== "boolean"
    ) {
      errors.push({
        path: ["markov", "autoSync"],
        message: "Expected a boolean.",
      });
    }
  }

  return errors;
}

/**
 * Resolves the plugin config, based on an already validated HardhatUserConfig
 * and a partially resolved HardhatConfig.
 *
 * This function is called from the `resolveUserConfig` Hook Handler.
 *
 * @param userConfig The HardhatUserConfig.
 * @param partiallyResolvedConfig The partially resolved HardhatConfig, which is
 *  generated by calling `next` in the `resolveUserConfig` Hook Handler.
 * @returns The resolved HardhatConfig.
 */
export async function resolvePluginConfig(
  userConfig: HardhatUserConfig,
  partiallyResolvedConfig: HardhatConfig,
): Promise<HardhatConfig> {
  // Resolve legacy myConfig
  const greeting = userConfig.myConfig?.greeting ?? "Hello";
  const myConfig = { greeting };

  // Resolve markov config with defaults
  const markov = {
    chain: userConfig.markov?.chain ?? "localhost",
    wallet: userConfig.markov?.wallet ?? "",
    gasPrice: userConfig.markov?.gasPrice ?? "auto",
    author: userConfig.markov?.author ?? "Anonymous",
    aiApiKey: userConfig.markov?.aiApiKey,
    aiModel: userConfig.markov?.aiModel ?? "gpt-4",
    governanceAddress: userConfig.markov?.governanceAddress,
    mcpEndpoint:
      userConfig.markov?.mcpEndpoint ?? "https://mcp.blockscout.com/mcp",
    agentverseApiToken: userConfig.markov?.agentverseApiToken,
    historyPath: userConfig.markov?.historyPath ?? ".markov/history.json",
    verbose: userConfig.markov?.verbose ?? false,
    autoSync: userConfig.markov?.autoSync ?? true,
  };

  return {
    ...partiallyResolvedConfig,
    myConfig,
    markov,
  };
}
