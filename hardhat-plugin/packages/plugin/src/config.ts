import { HardhatUserConfig } from "hardhat/config";
import { HardhatConfig } from "hardhat/types/config";
import { HardhatUserConfigValidationError } from "hardhat/types/hooks";
import type { BranchConfig, BranchUserConfig } from "./types.js";

/**
 * This function validates the parts of the HardhatUserConfig that are relevant
 * to the plugin.
 *
 * This function is called from the `validateUserConfig` Hook Handler.
 *
 * @param userConfig The HardhatUserConfig, as exported in the config file.
 * @returns An array of validation errors, or an empty array if valid.
 */
export async function validatePluginConfig(
  userConfig: HardhatUserConfig,
): Promise<HardhatUserConfigValidationError[]> {
  const errors: HardhatUserConfigValidationError[] = [];

  // Validate legacy myConfig
  if (userConfig.myConfig !== undefined) {
    if (typeof userConfig.myConfig !== "object") {
      errors.push({
        path: ["myConfig"],
        message: "Expected an object with an optional greeting.",
      });
    } else {
      const greeting = userConfig.myConfig?.greeting;
      if (greeting !== undefined) {
        if (typeof greeting !== "string" || greeting.length === 0) {
          errors.push({
            path: ["myConfig", "greeting"],
            message: "Expected a non-empty string.",
          });
        }
      }
    }
  }

  // Validate markov config
  if (userConfig.markov !== undefined) {
    if (typeof userConfig.markov !== "object") {
      errors.push({
        path: ["markov"],
        message: "Expected an object with markov configuration.",
      });
      return errors;
    }

    const markov = userConfig.markov as any;

    // Validate uppercase snake_case fields
    const stringFields = [
      "AGENTVERSE_API_TOKEN",
      "ASI_API_KEY",
      "Author",
      "Chain",
      "Governance_Address",
      "Wallet_Address",
    ];
    for (const field of stringFields) {
      const value = markov?.[field];
      if (value !== undefined && typeof value !== "string") {
        errors.push({ path: ["markov", field], message: "Expected a string." });
      }
    }

    // Validate numeric fields
    if (markov?.Gas_Price !== undefined && typeof markov.Gas_Price !== "number") {
      errors.push({ path: ["markov", "Gas_Price"], message: "Expected a number." });
    }

    // Validate boolean fields
    if (markov?.Auto_Sync !== undefined && typeof markov.Auto_Sync !== "boolean") {
      errors.push({ path: ["markov", "Auto_Sync"], message: "Expected a boolean." });
    }

    // Validate branches configuration
    if (markov.branches !== undefined) {
      if (typeof markov.branches !== "object") {
        errors.push({
          path: ["markov", "branches"],
          message: "Expected an object with branch configurations.",
        });
      } else {
        // Validate each branch configuration
        for (const [branchName, branchConfig] of Object.entries(markov.branches)) {
          if (typeof branchConfig !== "object") {
            errors.push({
              path: ["markov", "branches", branchName],
              message: "Expected an object with branch configuration.",
            });
            continue;
          }

          const branchStringFields = [
            "chain",
            "rpcUrl",
            "diamondAddress",
            "explorerApiKey",
            "explorerUrl",
          ];

          const bc: any = branchConfig as any;
          for (const field of branchStringFields) {
            const value = bc?.[field];
            if (value !== undefined && typeof value !== "string") {
              errors.push({
                path: ["markov", "branches", branchName, field],
                message: `Expected a string.`,
              });
            }
          }
        }
      }
    }
  }

  return errors;
}

/**
 * Resolves the plugin config, based on an already validated HardhatUserConfig
 * and a partially resolved HardhatConfig.
 *
 * This function is called from the `resolveUserConfig` Hook Handler.
 *
 * @param userConfig The HardhatUserConfig.
 * @param partiallyResolvedConfig The partially resolved HardhatConfig, which is
 *  generated by calling `next` in the `resolveUserConfig` Hook Handler.
 * @returns The resolved HardhatConfig.
 */
export async function resolvePluginConfig(
  userConfig: HardhatUserConfig,
  partiallyResolvedConfig: HardhatConfig,
): Promise<HardhatConfig> {
  // Resolve legacy myConfig
  const greeting = userConfig.myConfig?.greeting ?? "Hello";
  const myConfig = { greeting };

  // Resolve branch configurations
  const branches: Record<string, BranchConfig> = {};
  if (userConfig.markov?.branches) {
    for (const [name, userBranchConfig] of Object.entries(userConfig.markov.branches)) {
      branches[name] = {
        name,
        chain: userBranchConfig.chain ?? "localhost",
        rpcUrl: userBranchConfig.rpcUrl ?? "",
        diamondAddress: userBranchConfig.diamondAddress ?? "",
        explorerApiKey: userBranchConfig.explorerApiKey,
        explorerUrl: userBranchConfig.explorerUrl,
        createdAt: Date.now(), // Will be overwritten when loaded from storage
      };
    }
  }

  // Resolve markov config with defaults
  const m = (userConfig.markov as any) || {};
  const markov = {
    AGENTVERSE_API_TOKEN: m.AGENCYVERSE_API_TOKEN ?? m.AGENTVERSE_API_TOKEN, // tolerate minor typo if present
    ASI_API_KEY: m.ASI_API_KEY,
    Author: m.Author ?? "markov",
    Auto_Sync: m.Auto_Sync ?? true,
    Chain: m.Chain ?? "localhost",
    Gas_Price: m.Gas_Price ?? 10000,
    Governance_Address: m.Governance_Address,
    Wallet_Address: m.Wallet_Address ?? "",
    branches,
  } as any;

  return {
    ...partiallyResolvedConfig,
    myConfig,
    markov,
  };
}
