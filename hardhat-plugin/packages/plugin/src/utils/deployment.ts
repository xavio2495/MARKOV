/**
 * Deployment utilities for Markov plugin
 * Handles facet deployment, Ignition module generation, and DiamondCut execution
 */

import type { DeployedFacetInfo, DiamondCutResult, FacetCut } from "../types.js";
import type { HardhatRuntimeEnvironment } from "hardhat/types/hre";
import type { Address, Hash } from "viem";

/**
 * Parse facet names from comma-separated string
 */
export function parseFacetList(facetsArg: string): string[] {
  return facetsArg
    .split(",")
    .map((f) => f.trim())
    .filter((f) => f.length > 0);
}

/**
 * Validate facet name format
 */
export function isValidFacetName(name: string): boolean {
  // Must start with uppercase, alphanumeric only
  return /^[A-Z][a-zA-Z0-9]*$/.test(name);
}

/**
 * Get function selectors from contract ABI
 */
export function extractSelectors(abi: any[]): string[] {
  const selectors: string[] = [];
  
  for (const item of abi) {
    if (item.type === "function") {
      // TODO: Calculate selector from signature
      // For now, return empty array (will implement with viem)
    }
  }
  
  return selectors;
}

/**
 * Prompt user for action (add/replace/remove) for a facet
 */
export async function promptForAction(
  facetName: string,
  existingFacets: string[],
): Promise<0 | 1 | 2> {
  const readline = await import("node:readline/promises");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const isExisting = existingFacets.includes(facetName);
  const defaultAction = isExisting ? "replace" : "add";

  console.log(`\nFacet: ${facetName}`);
  if (isExisting) {
    console.log(`  ⚠️  Facet already exists on Diamond`);
  } else {
    console.log(`  ✓  New facet (not currently on Diamond)`);
  }

  const answer = await rl.question(
    `  Action (add/replace/remove) [${defaultAction}]: `,
  );
  rl.close();

  const action = answer.trim().toLowerCase() || defaultAction;

  switch (action) {
    case "add":
      return 0;
    case "replace":
      return 1;
    case "remove":
      return 2;
    default:
      console.log(`  Invalid action "${action}", using ${defaultAction}`);
      return defaultAction === "replace" ? 1 : 0;
  }
}

/**
 * Format gas used/estimate for display
 */
export function formatGas(gas: number): string {
  if (gas > 1_000_000) {
    return `${(gas / 1_000_000).toFixed(2)}M`;
  } else if (gas > 1_000) {
    return `${(gas / 1_000).toFixed(2)}K`;
  }
  return gas.toString();
}

/**
 * Estimate gas cost in ETH
 */
export function estimateCost(gasUsed: number, gasPriceGwei: number): string {
  const costWei = BigInt(gasUsed) * BigInt(gasPriceGwei) * BigInt(1_000_000_000);
  const costEth = Number(costWei) / 1e18;
  return costEth.toFixed(6);
}

/**
 * Create FacetCut object for DiamondCut
 */
export function createFacetCut(
  facetAddress: Address,
  action: 0 | 1 | 2,
  selectors: string[],
): FacetCut {
  return {
    facetAddress,
    action,
    functionSelectors: selectors,
  };
}

/**
 * Validate Diamond address format
 */
export function isValidAddress(address: string): boolean {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
}

/**
 * Generate Ignition module file content
 */
export function generateIgnitionModuleCode(
  facetName: string,
  constructorArgs: any[] = [],
): string {
  const argsString = constructorArgs.length > 0
    ? JSON.stringify(constructorArgs, null, 2)
    : "[]";

  return `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

/**
 * Ignition module for ${facetName}
 * Generated by Markov plugin
 */
const ${facetName}Module = buildModule("${facetName}Module", (m) => {
  const constructorArgs = ${argsString};
  
  const ${facetName.toLowerCase()} = m.contract("${facetName}", constructorArgs);

  return { ${facetName.toLowerCase()} };
});

export default ${facetName}Module;
`;
}

/**
 * Parse constructor parameters from contract artifact
 */
export async function parseConstructorParams(
  hre: HardhatRuntimeEnvironment,
  facetName: string,
): Promise<{ name: string; type: string }[]> {
  try {
    const artifact = await hre.artifacts.readArtifact(facetName);
    const constructorAbi = artifact.abi.find((item: any) => item.type === "constructor");
    
    if (!constructorAbi || !constructorAbi.inputs) {
      return [];
    }
    
    return constructorAbi.inputs.map((input: any) => ({
      name: input.name || "arg",
      type: input.type,
    }));
  } catch (error) {
    console.warn(`  ⚠️  Could not parse constructor for ${facetName}`);
    return [];
  }
}

/**
 * Prompt user for constructor argument values
 */
export async function promptForConstructorArgs(
  params: { name: string; type: string }[],
): Promise<any[]> {
  if (params.length === 0) {
    return [];
  }

  const readline = await import("node:readline/promises");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  console.log("\n  Constructor parameters:");
  const args: any[] = [];

  for (const param of params) {
    const answer = await rl.question(`    ${param.name} (${param.type}): `);
    // TODO: Parse value based on type (address, uint256, etc.)
    args.push(answer.trim());
  }

  rl.close();
  return args;
}

/**
 * Write Ignition module file to disk
 */
export async function writeIgnitionModule(
  hre: HardhatRuntimeEnvironment,
  facetName: string,
  moduleCode: string,
): Promise<string> {
  const fs = await import("node:fs/promises");
  const path = await import("node:path");
  
  const modulesDir = path.join(hre.config.paths.root, "ignition", "modules");
  await fs.mkdir(modulesDir, { recursive: true });
  
  const modulePath = path.join(modulesDir, `${facetName}.ts`);
  await fs.writeFile(modulePath, moduleCode, "utf-8");
  
  return modulePath;
}

/**
 * Generate and write Ignition module for a facet
 */
export async function generateIgnitionModule(
  hre: HardhatRuntimeEnvironment,
  facetName: string,
  constructorArgs: any[] = [],
): Promise<string> {
  const moduleCode = generateIgnitionModuleCode(facetName, constructorArgs);
  return await writeIgnitionModule(hre, facetName, moduleCode);
}

/**
 * Generate combined Ignition module for multiple facets
 */
export function generateCombinedModuleCode(
  facets: Array<{ name: string; args: any[] }>,
): string {
  const facetDefinitions = facets.map(({ name, args }) => {
    const argsString = args.length > 0 ? JSON.stringify(args, null, 4).split("\n").map(line => `    ${line}`).join("\n") : "    []";
    return `  const ${name.toLowerCase()} = m.contract("${name}", ${argsString});`;
  }).join("\n\n");

  const returnObj = facets.map(({ name }) => name.toLowerCase()).join(", ");

  return `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

/**
 * Combined Ignition module for Diamond facets
 * Generated by Markov plugin
 */
const DiamondFacetsModule = buildModule("DiamondFacetsModule", (m) => {
${facetDefinitions}

  return { ${returnObj} };
});

export default DiamondFacetsModule;
`;
}

/**
 * Write combined Ignition module for all facets
 */
export async function writeCombinedModule(
  hre: HardhatRuntimeEnvironment,
  facets: Array<{ name: string; args: any[] }>,
): Promise<string> {
  const fs = await import("node:fs/promises");
  const path = await import("node:path");
  
  const modulesDir = path.join(hre.config.paths.root, "ignition", "modules");
  await fs.mkdir(modulesDir, { recursive: true });
  
  const modulePath = path.join(modulesDir, "DiamondFacets.ts");
  const moduleCode = generateCombinedModuleCode(facets);
  await fs.writeFile(modulePath, moduleCode, "utf-8");
  
  return modulePath;
}

